# 210203 6일차 수업 정리

> [K-Digital\] 온·오프 연계 AI활용 지능형 서비스 개발 수업 6일차



## 1. 객체지향프로그래밍

> **재사용**을 하기위해 선택

### (1) 캡슐화

- 접근 지정자를 사용하는 것이 캡슐화가 아님
- data는 다른 클래스에서 접근하지 못하게하고 method를 public으로 사용하여 data에 접근할 수 있게 하는 것이 캡슐화
  - setter / getter 메서드
- data에 접근하여 값을 넣어줄 때 **유효성 검사**를 하는 것이 캡슐화의 **핵심**



### (2) 상속

- 실세계 객체를 모델링하면서 관계가 생김
- 단일 상속(단일 부모)
- `extands`  : `   ` is a ` `
- `class B extands A` : B가 A를 상속
- `class A` : A는 extands 가 없어도 `Objects` 클래스 상속
  - Object가 root
- 상속을 받아도 아버지가 가지고 있는 data와 같은 이름의 data 생성 가능
- 아버지가 가지고 있는 data의 값과 다른 값을 저장 가능
- 부모(super)의 private data는 상속 **불가**
- 계속 지향해야하는 방식

```java
class Shape {} // 타입 생성 목적
public class Circle {
	int radius;
	public void areaCircle() {
		System.out.println("원의 넓이="+(3.14*radius*radius));
	}
}

```

super type으로 하는 것은 제한하여 의도를 반영하기 위해

shadow effect를 해제 -> 타입 캐스팅 : 성능이 떨어짐

- shadow effect
  - super type으로 선언된 객체는 그 super type으로만 취급
  - 하위 타입 멤버는 가려짐

- 오버로딩 (Overloading)

  - 한 클래스에서 같은 이름의 메서드가 다수 존재하는 것
  - 같은 이름의 메서드의 매개변수를 다른 type으로 하여 매개변수에 따라 다른 메서드가 실행됨

  

- 오버라이딩(Overriding) -> 다형성의 일종

  - 상속을 하여 성능을 높이고 확장성을 높이기 위해 만들어진 방식

  - super(아버지)의 method를 sub(자식)에서 재정의 했을 때 super type으로 선언했어도 재정의 된 메소드가 가려지지 않는 규칙
  - super의 method에서는 정의만 해두고 구현하지 않고 sub에서 super의 method를 재정의
  - 오직 **method**에서만 적용



한 클래스가 다른 클래스 사용하는 방법

1. 객체화 (has a)
2. 상속(is a)

잘못 설계하면 eden -> old로 이동하게 된다. 용량이 커서

더이상 메모리를 확보하지 못하면 OOME



- tight coupling : 직접 연결되어 있는 것

- loose coupling : 관계성을 맺어주는 클래스를 (concept truck class?) 생성해서 연결하는 것



재사용을 잘 하기 위해서

1. 쓸모없는 연결을 줄인다.



program domain -> key abstraction(명사 뽑기) -> 분석(클래스 설계) : 어떤 관계성이 있는지 -> 정밀분석 - 시나리오(구체적) : 어떤 data가 필요할지 => 설계

절차지향 : 필요한 모든 data를 나열하고 쓰는 것

객체지향 : 커피는 product이다. 차는 product 이다. 케잌는 product이다.  -> 커피,차,..를 음료라는 클래스로 묶음-상속 or 재정의(data 같은이름X method 다시쓰는 것) => 음료를 자동으로 만드는 기계 클래스가 있다면 음료 클래스에서 오버라이딩 된 메소드를 호출하여 만약 다른 음료의 클래스가 생겨도 유지보수에 용이



과제 : problem domain 생각 - 식당 : 음식이 나오고 치워지고 => automatic하게 된다면 어떻게 해야하는가?



요구사항 수집 -> 분석 -> 설계(UML) -> 구현



### (3) 다형성 (Polymorphism)

- 다형적 변수(polymorphism variable) : super type으로 선언된 변수

  ```java
  public void print (Shape s) { //정의
      // Shape s : Circle, Rectangle, Triangle ... 모든 Shape의 하위 객체를 가리키는 변수
  }
  ```

- override (재정의)
  - super의 메소드를 sub에서 다시 정의하는 것
  - shadow effect를 우회하기 위함
  - 확장성과 성능 향상을 위해 사용