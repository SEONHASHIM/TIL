# 210207 C 공부 정리

> `(Do it!) C언어 입문 ` 책으로 공부하고 있습니다.
>
> 아래 내용은 책의 06~09단원의 정리 내용입니다.



## 1. 라이브러리

> C언어에서 좀 더 효과적으로 함수를 관리할 수 있도록 라이브러리 기술 제공

- 라이브러리 파일(*.lib)

  - 자신이 가지고 있는 함수들 중에서 실제로 다른 소스 파일에서 사용한 함수의 기계어만 분리할 수 있도록 목적 파일을 재구성한 것
  - 목적 파일을 변환해서 만들어짐
  - 소스 전체 저장 또는 소스 전체 컴파일 기능을 사용할 때 효율성이 떨어지는 것을 보완
  - 변경 가능성이 없는 파일들을 다른 곳에 보관해 두고, 소스 파일 대신 목적 파일을 소스 목록에 포함시켜 작업하는 것은 함수의 내용이 실제 사용 여부와 상관없이 모두 실행 파일에 포함된다는 단점이 있음
    - 개선하기 위해 라이브러리 개념 제공하게 됨
  - 기계어로 변환된 상태라 소스 코드를 볼 수 없음
    - 다른 사람에게 소스 코드를 공개하지 않고 함수들을 사용할 수 있게 해서 좋음

- 헤더 파일

  - 라이브러리 파일만 주면 다른 사람들은 해당 파일에 포함된 함수를 사용할 수 없음
    - C언어가 서로 다른 소스(목적 파일, 라이브러리 파일) 파일에 있는 함수를 참조하려면 함수 원형을 알아야 컴파일할 수 있기 때문
  - 헤더파일에서는 라이브러리 파일에 있는 함수를 사용하기 위해 각 함수 원형을 선언함

- 전처리기

  - 프로그래머가 원하는 사항을 컴파일러에게 직접 지시하는 문법

  - `#`기호로 시작하며 기계어로 번역되는 명령문이 아니므로 문법 끝에 `;`을 사용하지 않음

  - `#include "읽을 파일 이름"` 

    - 컴파일러에 자신이 명시한 파일을 읽도록 지시

    - 파일이름을 `" "`로 명시하면 컴파일러는 작업 경로(소스 파일이 있는 폴더의 경로)에서 해당 파일을 찾음 
    - 비쥬얼 스튜디오에서 제공하는 헤더 파일과 라이브러리 경로는 컴파일러가 이미 알고 있으며 `" "` 대신에 `< >`fmf tkdyd

    ```c
    #include "MyMath.h" //같은 작업 경로에 헤더파일이 있는 경우
    #include "C:\download\MyMath.h" //작업 경로에 없는 경우
    #include <stdio.h> //비쥬얼 스튜디오에서 제공하는 헤더 파일을 포함할 때
    ```

  - `#define`

    - 상수나 명령문을 치환하는 문법
    - 명령을 치환해서 사용하는 것이 함수를 호출하는 것과 유사하여 매크로 함수라고 이야기함

    ```c
    #define MAX_COUNT 3 // MAX)COUNT : 치환할 이름, 3 : 치환될 내용
    #define POW_VALUE(a) (a*a)
    int data = POW_VALUE(3); // int data = (3*3); 으로 번역됨
    ```

- 표준 라이브러리

  - 운영체제 별로 기술적 기반이 많이 달라 출력하는 과정과 방법이 다름

  - 운영체제에 영향을 받는 기능들을 표준 라이브러리를 이용하여 프로그래밍한다면 운영체제가 바뀌어도 소스 코드를 변경할 필요 없이 해당 운영체제에서 컴파일만 다시 한 후 실행할 수 있음

  - 소스 코드를 변경할 필요가 없기 때문에 라이브러리 형식으로 제공

  - 표준 출력함수

    - `putchar` : 하나의 매개변수를 가지는데 이 매개변수에 출력할 문자의 아스키 값을 명시

      ```c
      #define putchar(c) putc((c), stdout) // putc함수를 호출하도록 작성된 매크로 함수
      putchar(65); //아스키 값 65에 해당하는 문자 A 출력
      putchar('A'); //문자 A 출력
      ```

    - `puts` : 매개변수에 출력하려는 '문자열 상수' 또는 '문자열이 저장되어 있는 메모리의 시작 주소' 명시하며 줄바꿈 기능을 포함하고 있음

    - `printf` : 변수 값을 일정한 형식으로 출력하는 함수

      - 출력하다라는 의미의 print와 형식을 의미하는 format의 첫 자 f를 합쳐서 만들어짐
      - 문자열을 명시할 때 `%` 서식 지정 키워드 사용

      |  키워드  |      %d      |  %f  |  %c  |   %s   |
      | :------: | :----------: | :--: | :--: | :----: |
      | 출력형식 | 정수(10진수) | 실수 | 문자 | 문자열 |

      - 출력하고 싶은 변수는 printf 함수의 두번째 매개변수부터 원하는 개수만큼 `,`로 구분하여 사용하고, 출력하고 싶은 변수의 개수만큼 `%` 키워드를 사용하여 출력 형태를 짝지어줌

      ```c
      int step = 5;
      int value = 3*step;
      printf("3 * %d = %d", step, value) //첫번째 %d는 step과 짝이 되고 두번째 %d는 value와 짝을 이룸
      
      //출력결과 : 3* 5 = 15
      ```

      - `%c`는 변수가 가지고 있는 값을 아스키 표에 대응하는 문자로 출력

      - `%`와 함께 사용하는 키워드는 변수의 자료형과 일치하지 않아도 됨

        ```c
        char data = 65;
        printf("%c의 ASCII 값은 %d입니다.",data,data);
        
        //출력결과 : A의 ASCII 값은 65입니다.
        ```

      - 실수와 정수는 숫자를 표현하는 방식이 다름

        ```c
        float value = 2.1f //C언어는 실수형인 상수를 적으면 기본적으로 double 자료형으로 처리
        ```

      - 실수 값을 `%d` 또는 `%c`로 출력하면 정상적인 결과를 얻을 수 없음

      - `%u`는 변수 값을 부호를 고려하지 않는 10진 정수 형태로 출력

        ```c
        int data1 = -1;
        unsigned int data2 = 4294967295;
        printf("%d, %u, %d, %u",data1, data1, data2, data2);
        
        //출력결과 : -1, 4294967295, -1, 4294967295
        ```

      - `%d`와  `%u`는 변수 크기를 4바이트 값으로 변환하여 출력

      - `%o`는 8진수, `%x`는 16진수 형태로 정수 출력

      - `%e`와 `%E`는 실수를 지수 형태로 출력

      - `%출력 칸의 수d` 를 사용하여 출력 칸 수 조절을 할 수 있으며 출력되는 문자의 수보다 칸 수가 많으면 오른쪽 정렬로 문자 출력

        - 출력 칸 안에 있는 숫자를 `+`키워드를 사용하여 오른쪽으로 정렬하거나 `-`키워드를 사용하여 왼쪽으로 정렬 가능

      - `%전체 칸 수.소수점 자릿수f` : 실수의 소수점 자릿수 지정할 수 있으며 출력할 때 `.`도 출력칸 수에 포함되기 때문에 전체 자릿수 명시할 때 칸 수를 잘 계산해야함

        - 소수점 자릿수 변경할 떄는 반올림이 적용됨

      - % 자체를 출력하고 싶다면 %% 처럼 두번 연속 사용하면 됨

    - 제어 코드

      - 캐럿 : 콘솔의 출력과 입력의 현재 위치를 알려줌

      | 제어코드 | 기능                                            |
      | -------- | ----------------------------------------------- |
      | `\n`     | 캐럿을 다음 줄로 이동(Line Feed)                |
      | `\r`     | 캐럿을 해당 줄의 처음으로 이동(Carriage Return) |
      | `\t`     | 캐럿을 한 탭만큼 이동                           |
      | `\b`     | 캐럿을 바로 앞 칸으로 이동                      |
      | `\a`     | 시스템 스피커로 경고음 발생                     |
      | `\"`     | 큰따옴표 출력                                   |
      | `\'`     | 작은따옴표 출력                                 |



## 2. 연산자

1. 대입연산자
2. 산술연산자
3. 증감연산자
4. 관계연산자
5. 논리연산자



## 3. 제어문

> 프로그램의 실행 흐름을 제어하는 문법

### 3.1. 조건문

> 예외 사항에 대처하기 위한 문법

1. if조건문

2. if ~ else~ 조건문

3. if ~ else if ~else 조건문

4. 조건 수식 연산자 : `결과값 = (조건 수식) ? 수식1 : 수식2;`

   - 수식1 : 참일 때 실행해 결과 값에 저장
   - 수식2 : 거짓일 때 실행해 결과 값에 저장
   - 조건 수식 연산자는 단일 문장으로 구성된 명령문만 사용 가능

5. switch 조건문

   - 변수 값이 이미 정해져 있는 상수들과 비교할 때는 switch 조건문이 유리

   ```c
   명령문 1;
   swith(수식 또는 변수){
       case 상수1:
       	명령문2;
       	break;
       default: //조건 수식과 일치하는 case 상수가 없으면 수행함
       	명령문3;
       	break;
   }
   ```

   



### 3.2. 반복문

> 반복 행위를 효과적으로 표현하기 위한 문법
>
> 반복문 필수 요소 : 반복을 시작하기 위한 '시작 조건', 반복을 계속 진행할 것인지를 판단하는 '종결 조건', 반복의 조건을 바꾸기 위해 '조건 변화 수식'

1. for 반복문 : `for(시작 조건;종결 조건;조건 변화 수식) {명령문}`
   - 종결 조건이 거짓이 되면 for 반복문 종료
   - 3요소를 모두 사용할 필요가 없는 경우에는 해당 부분을 비워도 상관 없음
   - 반복의 3요소를 모두 적지 않으면 무한 루프
2. while 반복문 : `while(종결조건) {명령문}`
   - 사용하고 싶은 위치나 작업 순서에 맞게 시작 조건과 조건 변화 수식 배치
   - while(1)로 무한 루프 생성 가능
3. do ~ while 반복문 : `do{명령문;}while(종결 조건)`

- break 제어문 : 특정 상황에서 반복문이나 조건문을 종료시키고 싶을 때 사용
- continue 제어문 : 1회성 취소로 반복문이 명령을 실행하다가 continue문을 만나면 이후 명령들을 실행하지 않고 조건 변화 수식으로 돌아감
- goto 제어문 : 자신이 어떤 위치에 있든지 상관하지 않고 자신이 지정한 레이블로 이동
  - C언어의 구조화된 문법 파괴
  - 되도록 사용하지 않는 것이 좋음
  - break, return, continue와 같은 제어문으로 대체 가능

